# 型注釈をつける・入力を数値に変換する

複利計算をして、将来儲かるお金を計算しましょう💰:

1. 標準入力から3行の入力を受け取ります。
1. 1行目は元金の額として解釈します。
1. 2行目は1年間あたりの金利（**単位はパーセント**）として解釈します。
1. 3行目は預けた年数として解釈します。
1. 以上の入力を元に、預けた年数後の預入額を計算してください。

## 注意事項

- 小数点以下の値に対して、四捨五入などの丸め処理をする必要はありません。
- 浮動小数点数の丸め誤差を気にする必要もありません。

## 実行結果例

「元金100円、金利1%で2年間預けた場合」を計算した結果です。

```bash
shell> stack exec runhaskell 5.hs
100 # ここはユーザーが入力する箇所
1   # ここもユーザーが入力する箇所
2   # ここまでユーザーが入力する箇所
102.01
```

## 必要な知識

### `getLine`で標準入力から1行ずつ読み出す

前回の課題では、`getContents`という命令を使って、標準入力からすべての文字列を読み出す方法を習いました。  
今回の課題では、「標準入力から3行の入力を」受け取り、なおかつ各行で受け取った文字列を別々に扱う必要があります。  
標準入力から1行ずつ読まなければならないでしょう。  
そのために使う関数は`getLine`といいます。

早速GHCiで試してみましょう。

```haskell
ghci> getLine
```

`getLine`と入力してEnterキーやReturnキーを押した時点では、プロンプトが表示されず、GHCiが止まったように見えますよね。  
これは`getLine`関数が標準入力から入力を待ち受けている証拠です。  
そのまま適当な文字列を入力してEnterまたはReturnを押せば、入力した結果がGHCiによって出力されるはずです。

```haskell
ghci> getLine
This is a line I entered!
--                       ^ ここでEnterまたはReturn
"This is a line I entered!"
-- ^ これはGHCiが`getLine`を実行した結果を出力したもの
ghci>
```

EnterやReturnを押した直後に出てきた文字列、ここでは`"This is space: , and newline:"`に注目してください。  
これは`getLine`を実行した結果の文字列を、Haskellにおける文字列リテラルの形式で出力したものです。  
Rubyで言うところの`inspect`、Pythonで言うところの`repr()`を実行した結果だと言えば通じるでしょうか？  
非印刷文字や改行文字など、普通に`putStrLn`や`putStr`で表示しようとするとわかりづらい文字も見やすくしてくれます。

### 入力を数値に変換する

続いて、`getLine`で受け取った文字列を数値に変換することで、足し算やかけ算などの計算に使えるようにしましょう。  
そのためには、`read`という関数を使います。

ただし、この`read`関数、GHCiで扱う際は非常にやっかいな性質を持っています。  
そのまま試そうとしても、下記のようにエラーになってしまうでしょう。

```haskell
ghci> read "2.0"
*** Exception: Prelude.read: no parse
```

これを避けるためにはいくつかの方法があります。まずは最も確実な方法をお伝えします。

#### 型推論とは

...と、その前に、重要な話なのでこのエラーの詳細について解説させてください。  
少し難しい話ですがどうかお付き合いを。🙏  
少なくとも今回の課題を解くだけであれば必要ないので、難しい場合は次の節まで飛ばしてしまうのもありかもしれません。

先ほどのエラーは、Haskellの「型推論」という機能と、そのデフォルト設定が組み合わさってしまったことによるエラーです。

さて、「型推論」とは一体なんでしょうか？  
文字通り「型」を推論する機能なのですが、そもそもその「型」とは何か、といった点から説明したいと思います。  
Haskellやその他の多くのプログラミング言語において「型」とは、「文字」や「整数」、「文字列」といった、値の「種類」を表す分類です。  
Haskellは静的型付言語であるため、Haskellのソースコードに現れるありとあらゆる式は、プログラムとして実行する前の時点でなんらかの「型」に分類されます。  
これは、これまでの課題で代入した、`main`関数や、`getContents`を実行した結果を結びつけた、変数も例外ではありません。

他の静的型付け言語を経験した方であれば、`main`関数や`getContents`を実行した結果を代入した際に、型注釈を書かなかったことにお気づきかもしれません。  
実はHaskellは、静的型付け言語でありながら、多くの箇所で型注釈を書かなくてもよいことになっています。  
それを可能にしてくれているのが「型推論」という機能です。

「型推論」は、実際に関数や変数を含む式がどのように使われているかを見ることで、自動で式の型を決定してくれる機能です。  
これまでの課題では、私たちは文字列（例えば`"Hello, world!"`）や数値（例えば`60`や`1.7`）といった値について、それらが何の型であるか、特に意識せずに扱うことができました。  
こうしたことができるのは、型推論のおかげなのです。

型推論は`read`関数のような、様々な型の値を返すことができる関数（「多相関数」と呼ばれます）を簡単に扱えるようにするためには、とても重要な機能です。  
しかし、「様々な型の値を返すことができる関数」はその原理上、型推論にとってやっかいなものになることがあります。  
Haskellの強力な型推論機能を持ってしても、**どんな型の値を返すか決定できない場合がある**のです。  
例えば先ほどのようにGHCiの中で`read`関数を使用した場合がその典型的なケースです。  
`read`関数の**返す値**はその性質上、「様々な型の値」になり得ます。  
そして、GHCiが私たちにHaskellの式を評価した場合に表示する関数 --- 第2章で学習した`print`関数が使われているのですが --- は、「様々な型の値」を**引数として受け取る**関数（これも「多相関数」と呼ばれます）となっています。  
このように、「様々な型の値」を返す関数と、それを引数として受け取る関数が組み合わさった式を見つけると、型推論機能は決定不能に陥ってしまいます。

通常であれば、そうした場合Haskellは決定できなかった式を「曖昧な(ambiguous)型」として扱い**型エラー**にします。  
しかし、それでは困る場合が（特に、GHCiのように短い式を評価することが多いプログラムでは）あるので、Haskellは一部のケースにおいて「曖昧な型」をエラーとしないで、代わりに「デフォルトの型」として解釈することにしています。  
それが今回エラーを起こした`read "2.0"`の結果の型なのです。  
GHCiは「`read "2.0"`の結果を`print`関数で表示する式」を型推論する際、`print`関数の引数の型をそのデフォルトの型である`()`という変な名前の型として解釈します。「ユニット」と呼ばれています。  
この「ユニット」という型の値を`read`関数によって（無事、エラーを起こさず）返させるには、`"()"`という文字列を与えればよいのです。

```
ghci> read "()"
()
```

`*** Exception`などと出ていませんね。これはちゃんとエラーを起こさず`read "()"`を実行できた証拠です！よかった！😌

#### 確実な解決方法: 型注釈をつける

... いや、`read "()"`をエラーを起こさずに実行できてもあまりうれしいことはありません。  
私たちがエラーを起こさずに実行したいのは`read "2.0"`の方です。
hoge

#### よくある解決方法: 

一方でこの問題は、もう少し大きなHaskellのプログラムを書く場合、問題にならないことが多いです。  
少なくとも今回の課題を解くだけであれば、気にしなくて良いはずです。  
型推論機能がちゃんと働いて、どんな型なのかを適切に判断できるような式を書けばよいのです。それだけです。  
例えば今回の`read "2.0"`であっても、次のように`+ 0.0` と着けるだけでエラーを回避できます。

```haskell
ghci> read "2.0" + 0.0
2.0
```

これは、`read "2.0"`の結果に対して`+ 0.0`という計算をしようとしていることから、Haskellの型推論機能が「あっ、この`read "2.0"`の結果は数値として解釈すればいいんだ！」と判断しているためです。

### 複利計算の公式

それでは肝心の、「預けた年数後の預入額」を計算する際の式をHaskellで書いてみましょう。  
日本語で言うと、次のような式で計算されます。

```
預けた年数後の預入額 = 元金 × (1 + 年利)の「年数」乗
```

おっと、「『年数』乗」ということは、累乗の計算が必要ですね。  
ほかのプログラミング言語で累乗を計算する際は`**`や`^`という演算子、はたまた`pow`関数などを使用しますが、Haskellでは果たして何を使うのでしょうか！？

... 答えはキャレット `^` です！

```haskell
ghci> 2 ^ 10
1024
```

そして、ここで言う「年利」は問題の仕様上、パーセントとして入力されるため、100で割る必要があります。  
つまり次のような式になりますね。

```
預けた年数後の預入額 = 元金 × (1 + 年利(%) ÷ 100) ^ 年数
```

第2章で習ったとおり、足し算・かけ算・割り算にはそれぞれ `+`, `*`, `/` を使います。  
元金・年利(%)・預けた年数をそれぞれ`principal`・`interestRate`・`years`という変数に割り当てれば、最終的に下記のようなHaskellの式になるでしょう:

```haskell
principal * (1 + interestRate / 100) ^ years
```

## 課題の解き方

今回も課題4と同様、`do`記法の中で`<-`を使って`getLine`関数の実行結果を代入するのがポイントです。  
`getLine`で読んだ各行を変数に代入した後は、`read`関数で数値に変換しつつ、上記の複利計算の式に当てはめましょう。  
「Haskellでは関数呼び出しが最も優先して結合される」というルールを思い出しつつ、カッコで囲う場所にはくれぐれも気をつけてください。
